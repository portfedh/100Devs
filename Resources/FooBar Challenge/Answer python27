def is_divisible_by_1(d):
    """
    Returns True if a given digit d is divisible by 3 with a remainder of 1.
    """
    return d % 3 == 1

def is_divisible_by_2(d):
    """
    Returns True if a given digit d is divisible by 3 with a remainder of 2.
    """
    return d % 3 == 2

def solution(L):
    # Sort the digits in descending order so we can consider larger numbers first.
    digits = sorted(L, reverse=True)

    # Calculate the remainder of the sum of the digits when divided by 3.
    remainder = sum(digits) % 3

    if remainder == 0:
        # If the remainder is 0, then we can form a number that is divisible by 3 using all the digits.
        return int("".join(map(str, digits)))

    candidates = []
    for i in range(len(digits)):
        d = digits[i]
        if remainder == 1 and is_divisible_by_1(d):
            # If the remainder is 1 and there is a digit that is divisible by 3 with a remainder of 1,
            # then we can remove that digit to form a number that is divisible by 3.
            candidate = digits[:i] + digits[i+1:]
            if candidate != []:
                candidates.append(candidate)
        elif remainder == 2 and is_divisible_by_2(d):
            # If the remainder is 2 and there is a digit that is divisible by 3 with a remainder of 2,
            # then we can remove that digit to form a number that is divisible by 3.
            candidate = digits[:i] + digits[i+1:]
            if candidate != []:
                candidates.append(candidate)

    if len(candidates) == 0:
        # If we cannot form a number that is divisible by 3 by removing a single digit,
        # then we need to remove two digits to form a number that is divisible by 3.
        if remainder == 1 and len(digits) >= 3:
            # If the remainder is 1 and there are at least 3 digits, then we can remove two digits that are divisible by 3 with a remainder of 1.
            for d in digits:
                if is_divisible_by_1(d):
                    digits.remove(d)
                    break
            for d in digits:
                if is_divisible_by_1(d):
                    digits.remove(d)
                    break
            return int("".join(map(str, digits)))
        elif remainder == 2 and len(digits) >= 3:
            # If the remainder is 2 and there are at least 3 digits, then we can remove two digits that are divisible by 3 with a remainder of 2.
            for d in digits:
                if is_divisible_by_2(d):
                    digits.remove(d)
                    break
            for d in digits:
                if is_divisible_by_2(d):
                    digits.remove(d)
                    break
            return int("".join(map(str, digits)))
        else:
            # If we cannot form a number that is divisible by 3 by removing one or two digits, then it is not possible.
            return 0

    max_candidate = candidates[0]
    for i in range(1, len(candidates)):
        candidate = candidates[i]
        if int("".join(map(str, candidate))) > int("".join(map(str, max_candidate))):
            # Find the largest candidate number and return it.
            max_candidate = candidate

    return int("".join(map
